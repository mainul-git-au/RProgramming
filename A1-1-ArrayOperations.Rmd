---
title: "A1-A-ArrayOperations"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Question 1


1. Assign a variable called loanAmount with the value 375000.

2. Assign an array called interestRate with 7 numbers,  4, 4.5, 5, 5.5, 6, 6.5 and 7. 

3. Write a single expression to work out the remaining principal if a repayment of $50000 is made after a year of interest being added to loanAmount for each of these interestRates (no compounding).


```{r}

# Write your code and your comments here.
loanAmount <- 375000
interestRate <- c(4, 4.5, 5, 5.5, 6, 6.5, 7)
paidAmount <- 50000
remainingPrincipal <- loanAmount * (1 + interestRate/100) - paidAmount
remainingPrincipal
# Any plot you generate will be shown in the document.

```

# Question 2

1. Assign `loanAmount` with 50000 and 1050000. You can choose the step, and thus the granularity.

2. Assign a variable `interestRate` with a value 2. 

3. Calculate a vector `annualInterest` that represents the interest charged for each of the `loanAmount` values.

4. Calculate `principalPaid`, based on repaying an annual sum of $25000 (no compounding). 

5. Do the following: `data.frame(loanAmount, annualInterest, principalPaid)`

```{r}

# Write your code and your comments here (delete these comments).
loanAmount = c(50000, 1050000)
interestRate = 2
annualInterest = loanAmount*interestRate/100
annualInterest
principalPaid = 25000 - annualInterest
principalPaid

# Any plot you generate will be shown in the document.

```

# Question 3

1. Make a vector `val`, which is a `seq()` from 0 to `2*pi`. You can choose the increment, but I'd recommend something like `2 * pi / 256`

2. Make a vector `sine_wave`, by applying a function `sin()` to the vector `val`.

3. Make a vector `cosine_wave`, by applying a function `cos()` to the vector `val`.

4. Plot the vector `sine_wave` on the x axis, and `cosine_wave` on the y axis of a scatterplot (or a line plot).  

```{r}

# Write your code and your comments here.
val = seq(0, 2*pi, 2*pi/256)
val
plot(val, sin(val))
plot(val, cos(val))
plot(sin(val), cos(val), type="l")
# Any plot you generate will be shown in the document.

```

# Question 4

1. Create a `seq()` of integers from 1 to 256.

2. Take a modulo (`%%`) of the `seq()` by 2, 4, and 8, and place them in separate vectors. Apply `==0` to show True only when the value is 0 and re-save the remaining values to another vector. 

3. `plot` each of these using firstly a `plot` command with `type='s'` and set to a colour, followed by a `lines` command to overlay another line on the plot. 

4. You should end up with multi-coloured stripes. 

```{r}

# Write your code and your comments here.
integerSeq = seq(1, 256, 1)

moduloByTwo = integerSeq%%2
integerSeqModuleTwoZero = integerSeq[moduloByTwo == 0]
integerSeqModuleTwoNotZero = integerSeq[moduloByTwo != 0]

moduloByFour = integerSeq%%4
integerSeqModuleFourZero = integerSeq[moduloByFour == 0]
integerSeqModuleFourNotZero = integerSeq[moduloByFour != 0]

moduloByEight = integerSeq%%8
integerSeqModuleEightZero = integerSeq[moduloByEight == 0]
integerSeqModuleEightNotZero = integerSeq[moduloByEight != 0]

plot(integerSeqModuleTwoZero, type='s', col="blue")
plot(integerSeqModuleFourZero, type='s', col="red")
plot(integerSeqModuleEightZero, type='s', col="green")
plot(integerSeqModuleTwoNotZero, type='s', col="yellow")
plot(integerSeqModuleFourNotZero, type='s', col="black")
plot(integerSeqModuleEightNotZero, type='s', col="cyan")
# Any plot you generate will be shown in the document.

```

# Question 5

1. Create a ramp with `seq` that starts at 0 and increases to 1 by a small increment of your choice. 

2. Create a `seq` vector of the same length, made up of pseudo-random numbers generated by using `rnorm` (mean 0 and SD between 0 and 1). 

3. Add the two vectors element-by-element to generate a noisy ramp and plot it.

```{r}

# Write your code and your comments here.
ramp = seq(0, 1, 0.005)
pseduoRamp = rnorm(201, 0, 1)
noisyRamp = ramp + pseduoRamp
plot(ramp, noisyRamp, type = "l")


# Any plot you generate will be shown in the document.

```

# Question 6

1. Create a sine wave of the same length (number of samples) as the noisy ramp, with 4 cycles of the sine wave happening within that length. (Hint: 1 cycle is created by ramping from `0` to `2*pi`. Try ramping up to `8 * pi`).

2. Add it to your noisy ramp. 

3. Plot it. What might that look like, generally speaking?


```{r}

# Write your code and your comments here.

ramp = seq(0, 1, 1/256)
pseduoRamp = rnorm(257, 0, 1)
noisyRamp = ramp + pseduoRamp

val = seq(0, 8*pi, 8*pi/256)
result = noisyRamp + val
plot(sin(result), type="l")

# Any plot you generate will be shown in the document.

```

# Question 7

1. Take your noisy cyclic ramp and create a new vector of the same length, where each value is the average of itself and the value before it. Decide what to do with the missing value. 

2. Do the same thing but use 4 previous values for the averaging. 



```{r}

# Write your code and your comments here.

ramp = seq(0, 1, 1/256)
pseduoRamp = rnorm(257, 0, 1)
noisyRamp = ramp + pseduoRamp

val = seq(0, 8*pi, 8*pi/256)
noisyCyclicRamp = noisyRamp + val
noisyCyclicRamp
plot(noisyCyclicRamp)

# Any plot you generate will be shown in the document.

```

# Question 8

1. Take the noisy cyclic ramp and subtract each value with the value before it. 

2. How much noise is there in this noisy signal, when compared with the clean signal? (Hint: Noise can be represented as root mean square values, which means you square the noise values, then take a mean, and then take the square root of that value).


```{r}

# Write your code and your comments here.

# Any plot you generate will be shown in the document.

```

